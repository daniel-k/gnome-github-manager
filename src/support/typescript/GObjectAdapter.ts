import ts from 'typescript';

/**
 * Class to adapt the javascript generated by typescript for GObjects. The transformer only affacts classes decorated
 * with @registerGObject. Currently the following modifications are applied:
 *
 * 1) The constructor is converted to an _init() method with the same parameters.
 * 2) Any reference to the super constructor is translated to super._init() with the same parameters.
 *
 * This changes are needed for compatibility with GNOME 41. object constructor is in fact supported only from GJS 1.72
 * aka GNOME 42.
 */
export default class GObjectAdapter {
    private static readonly GOBJECT_ANNOTATION: string = '@registerGObject';

    private gobjects: string[];

    public constructor() {
        this.gobjects = [];
    }

    public beforeCompilation(context: ts.TransformationContext): ts.Transformer<ts.SourceFile> {
        return (sourceFile) => {
            const visitor = (node: ts.Node): ts.Node => {
                if (ts.isClassDeclaration(node) && this.isDecoratedClass(node, GObjectAdapter.GOBJECT_ANNOTATION)) {
                    const className = node.name?.text;
                    if (className !== undefined) {
                        console.log('[GObjectAdapter] Adapting GObject %s.', className);
                        this.gobjects.push(className);
                    }

                    return node;
                }

                return ts.visitEachChild(node, visitor, context);
            };

            return ts.visitNode(sourceFile, visitor);
        };
    }

    public afterCompilation(context: ts.TransformationContext): ts.Transformer<ts.SourceFile> {
        return (sourceFile) => {
            let className: string | undefined;

            const constructorBodyVisitor = (node: ts.Node): ts.Node => {
                if (
                    ts.isExpressionStatement(node) &&
                    ts.isCallExpression(node.expression) &&
                    node.expression.expression.kind === ts.SyntaxKind.SuperKeyword
                ) {
                    // Return a call to super._init() with the same arguments
                    return context.factory.createExpressionStatement(
                        context.factory.createCallExpression(
                            context.factory.createPropertyAccessExpression(context.factory.createSuper(), '_init'),
                            node.expression.typeArguments,
                            node.expression.arguments
                        )
                    );
                }

                return node;
            };

            const gobjectClassVisitor = (node: ts.Node): ts.Node | undefined => {
                if (ts.isConstructorDeclaration(node)) {
                    // Replace the constructor declaration with a _init() with the same argoment
                    return context.factory.createMethodDeclaration(
                        node.modifiers,
                        node.asteriskToken,
                        '_init',
                        node.questionToken,
                        node.typeParameters,
                        node.parameters,
                        node.type,
                        // Visit each child to replace any super constrcutor reference
                        ts.visitEachChild(node.body, constructorBodyVisitor, context)
                    );
                }

                return node;
            };

            const visitor = (node: ts.Node): ts.Node => {
                if (ts.isClassDeclaration(node) || ts.isClassExpression(node)) {
                    className = node.name?.getText();
                    if (className !== undefined && this.gobjects.includes(className)) {
                        return ts.visitEachChild(node, gobjectClassVisitor, context);
                    }
                }

                return ts.visitEachChild(node, visitor, context);
            };

            return ts.visitNode(sourceFile, visitor);
        };
    }

    private isDecoratedClass(node: ts.ClassDeclaration, decorator: string): boolean {
        const decorators = ts.getDecorators(node) ?? [];
        if (decorators.length === 0) {
            return false;
        }

        return decorators.find((n) => n.getText() === decorator) !== undefined;
    }
}
